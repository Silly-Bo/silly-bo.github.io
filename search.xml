<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F04%2F16%2Fvuex%2F</url>
    <content type="text"><![CDATA[vue状态管理]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript内置对象Math、Date……]]></title>
    <url>%2F2019%2F03%2F26%2Fnewpage-1%2F</url>
    <content type="text"><![CDATA[JavaScript提供了一些内置的对象和函数，内置对象提供编程的几种最常用的功能，JavaScript内置对象有以下几种。Math对象：处理所有的数学运算Date对象：处理日期和时间的存储、转化和表达String对象：处理所有的字符串操作Array对象：提供一个数组的模型、存储大量有序的数据Boolean对象：布尔对象，一个布尔变量就是一个布尔对象(没有可用的属性和方法)Number对象：数值对象,一个数值变量就是一个数值对象RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具Event对象：提供JavaScript事件的各种处理信息 一、Math与其它全局对象不同的是, Math 不是一个构造器. Math 的所有属性和方法都是静态的. 1. 属性下面列出来的属性，好像我用到过的就Math.PI.12345678Math.E // 2.718281828459045Math.PI // 圆周率，一个圆的周长和直径之比 3.141592653589793Math.LN2 // 2的自然对数, 约等于0.693.Math.LN10 // 10的自然对数, 约等于 2.303.Math.LOG2E // 以2为底E的对数, 约等于 1.443.Math.LOG10E // 以10为底E的对数, 约等于 0.434.Math.SQRT1_2 // 1/2的平方根, 约等于 0.707.Math.SQRT2 // 2的平方根,约等于 1.414. 2.方法一大堆方法里面，反正我用到的不是很多，相对较为常用的放在的了最下方，注意ceil，和floor值为负数的时候取整，不能被负数给带到坑里面了12345678910111213141516171819202122232425262728293031323334353637Math.abs(x) // 返回x的绝对值.Math.acos(x) // 返回x的反余弦值.Math.acosh(x) // 返回x的反双曲余弦值.Math.asin(x) // 返回x的反正弦值.Math.asinh(x) // 返回x的反双曲正弦值.Math.atan(x) // 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值.Math.atanh(x) // 返回 x 的反双曲正切值.Math.atan2(y, x) // 返回 y/x 的反正切值.Math.cbrt(x) // 返回x的立方根.Math.clz32(x) // 返回一个32位整数的前导零的数量。Math.cos(x) // 返回x的余弦值.Math.cosh(x) // 返回x的双曲余弦值.Math.exp(x) // 返回 Ex, 当x为参数, E 是欧拉常数 (2.718...), 自然对数的底.Math.expm1(x) // 返回 exp(x)-1 的值.Math.fround(x) // 返回数字的最接近的单精度浮点型表示.Math.hypot([x[,y[,…]]]) // 返回其参数平方和的平方根。Math.imul(x) // 返回32位整数乘法的结果。Math.log(x) // 返回一个数的自然对数（loge， 即ln）。Math.log1p(x) // 返回 1 加上一个数字的的自然对数（loge， 即ln）。Math.log10(x) // 返回以10为底数的x的对数。Math.log2(x) // 返回以2为底数的x的对数。Math.max([x[,y[,…]]]) // 返回0个到多个数值中最大值.Math.min([x[,y[,…]]]) // 返回0个到多个数值中最小值.Math.sign(x) // 返回x的符号函数, 判定x是正数,负数还是0.Math.sin(x) // 返回正弦值.Math.sinh(x) // 返回x的双曲正弦值.Math.tan(x) // 返回x的正切值.Math.tanh(x) // 返回x的双曲正切值.Math.toSource()// 返回字符串 "Math".Math.trunc(x) // 返回x的整数部分,去除小数.Math.round(x) // 返回四舍五入后的整数.Math.random() // 返回0到1之间的伪随机数([0 1)包括0，不包括1）Math.pow(x,y) // 返回x的y次方.Math.sqrt(x) // 返回x的平方根.Math.ceil(x) // 返回x向上取整后的值（向上取整）.Math.floor(x) // 返回小于x的最大整数（向下取整）. 二、DateDate对象基于1970年1月1日（世界标准时间）起的毫秒,new Date()根据本地时间返回，里面也有很多方法可以获取到指定的年月日时分秒毫秒等，也可以设置时间，值得注意的是，获取月份的时候是个坑，因为月份是从0开始的，获取月份（0-11）,也就是1月份是0，所以一般将获取到的月份+1，达到我们正常的（1-12）月 1. 属性Date.prototype 属性表示Date构造函数的原型1Date.prototype 2. 方法12345678910111213141516var myDate = new Date() // 创建一个日期对象myDate.getFullYear() // 返回年份 myDate.getMonth() // 返回月份数（0-11） myDate.getDay() // 返回星期中第几天(0-6),想要得到星期几，需要+1myDate.getDate() // 返回日myDate.getHours() // 返回时myDate.getMinutes() // 返回分myDate.getSeconds() // 返回秒myDate.getTime() // 返回从1970年1月1日00:00到现在的毫秒数(时间戳)myDate.setFullYear() // 设置年份(4位数)myDate.setMonth() // 设置月份(0-11)myDate.setDate() // 设置日(1-31)myDate.setHours() // 设置小时数(0-23)myDate.setMinutes() // 设置分钟数(0-59)myDate.setSeconds() // 设置秒数(0-59)myDate.setMilliseconds() // 设置毫秒(0-999) 三、String1. 属性123constructor // 对创建该对象的函数的引用length // 字符串的长度prototype // 允许您向对象添加属性和方法 2. 方法1234567891011121314151617181920212223242526272829303132333435anchor() // 创建 HTML 锚。big() // 用大号字体显示字符串。 small() // 使用小字号来显示字符串。blink() // 显示闪动字符串。 bold() // 使用粗体显示字符串。fixed() // 以打字机文本显示字符串。 fontcolor() // 使用指定的颜色来显示字符串。fontsize() // 使用指定的尺寸来显示字符串。fromCharCode() // 从字符编码创建一个字符串。italics() // 使用斜体显示字符串。localeCompare()// 用本地特定的顺序来比较两个字符串。toSource() // 代表对象的源代码。link() // 将字符串显示为链接。lastIndexOf() // 从后向前搜索字符串。indexOf() // 检索字符串。charAt() // 返回在指定位置的字符。charCodeAt() // 返回在指定的位置的字符的 Unicode 编码。 concat() // 连接字符串。match() // 找到一个或多个正则表达式的匹配。replace() // 替换与正则表达式匹配的子串。search() // 检索与正则表达式相匹配的值。slice() // 提取字符串的片断，并在新的字符串中返回被提取的部分。split() // 把字符串分割为字符串数组。strike() // 使用删除线来显示字符串。sup() // 把字符串显示为上标。sub() // 把字符串显示为下标。 substr() // 从起始索引号提取字符串中指定数目的字符。substring() // 提取字符串中两个指定的索引号之间的字符。toLocaleLowerCase() // 把字符串转换为小写，通常和toLowerCase()一样。toLocaleUpperCase() // 把字符串转换为大写，通常和toUpperCase()一样。toLowerCase() // 把字符串转换为小写。toUpperCase() // 把字符串转换为大写。toString() // 返回字符串。valueOf() // 返回某个字符串对象的原始值。 举栗子因为string平时操作的太多了，举个例子先 anchor() 创建 HTML 锚。这里加这么多的&lt;/br&gt;为的就是让页面出现滚动条，这个的时候点击html中自己定义的锚链接按钮，然后就会链接到通过str.anchor(&#39;anchorname&#39;)方法定义锚点上面了 123&lt;a href=&quot;#anchorname&quot;&gt;锚链接&lt;/a&gt; var str = &apos;hello world&apos; document.write(`&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;` + str.anchor(&apos;anchorname&apos;)) link() 用于把字符串显示为超链接。 这里是通过link()方法，生成a标签，然后将地址挂在a标签的href上 12 var str = '点击我传送至百度'document.write(str.link('https://www.baidu.com')) lastIndexOf() 从后向前搜索字符串。 12 参考：W3school]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery事件绑定方式有哪些]]></title>
    <url>%2F2019%2F03%2F25%2Fnewpage%2F</url>
    <content type="text"><![CDATA[jQuery中提供了四种事件监听方式bing、live、delegate、on，对应的解除监听的函数分别是unbind、lie、undelegate、off bind()直接绑定在元素上bind(type,[data],function(){})type:事件类型，如click、change、mouseover等;data:传入监听函数的参数，通过event.data取到。可选;function:监听函数，可传入event对象，这里的event是jQuery封装的event对象，与原生的event对象有区别 12345678源码： bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;$('#btn li').bind('click',function()&#123;&#125;) live()通过冒泡的方式绑定到元素上的，更适合列表类型的，绑定到document DOM节点上，和bind()不一样，live支持动态数据 1234567live: function( types, data, fn ) &#123; jQuery( this.context ).on( types, this.selector, data, fn ); return this; &#125; 可以看到live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了,正常来说就是document了，live没有将事件绑定在自己的身上而是事件委托绑在了document上 delegate()参数多了一个selector，用来指定触发事件的目标元素，监听器将被绑定在调用此方法的元素上，小范围的使用事件代理，性能要优于live() 12345delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; on$(selector).on(event,childSelector,data,function)1.7版本新添加的，也是推荐使用的事件绑定方法。其实bind、live、delegate都是通过该方法实现的： 1234567891011121314151617181920212223bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn );&#125;,unbind: function( types, fn ) &#123; return this.off( types, null, fn );&#125;,live: function( types, data, fn ) &#123; jQuery( this.context ).on( types, this.selector, data, fn ); return this;&#125;,die: function( types, fn ) &#123; jQuery( this.context ).off( types, this.selector || "**", fn ); return this;&#125;,delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn );&#125;,undelegate: function( selector, types, fn ) &#123; return arguments.length == 1 ? this.off( selector, "**" ) : this.off( types, selector, fn ); 使用on方法和上面方法一样1234567891011// Bind$( "#members li a" ).on( "click", function( e ) &#123;&#125; ); $( "#members li a" ).bind( "click", function( e ) &#123;&#125; );// Live$( document ).on( "click", "#members li a", function( e ) &#123;&#125; ); $( "#members li a" ).live( "click", function( e ) &#123;&#125; );// Delegate$( "#members" ).on( "click", "li a", function( e ) &#123;&#125; ); $( "#members" ).delegate( "li a", "click", function( e ) &#123;&#125; ); 参考：https://blog.csdn.net/liwenfei123/article/details/80408537]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装和基础代理配置]]></title>
    <url>%2F2019%2F03%2F24%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[一、安装windows电脑可以通过点击Nginx到官方网址进行下载，Mac电脑可以通过brew(又叫homebrew，Mac中的一款软件包管理工具）通过命令进行下载，下面是通过windows电脑演示 安装点击Nginx到官方网址下载 将下载的文件解压，放在的C盘下面，打开文件夹，找到nginx.exe直接点击启动，也可以通过CMD终端，cd到文件夹下输入strat nginx启动 12345678网上找的一些nginx常用命令start nginx 开启nginxnginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。nginx -s reopen 重新打开日志文件。nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。。nginx -v 显示 nginx 的版本。 启动后在浏览器地址栏输入localhost:8080,就会显示下图页面了 二、配置 找到nginx解压后的文件夹，我的文件夹在c盘根目录 1C:\nginx-1.14.2 打开的文件夹中找到nginx.conf文件并打开，找到下面的这个代码，在下面加一段代码include servers/*,如果有这段代码，直接将前面的#去掉，然后在跟nginx.conf同级目录下，创建一个servers文件夹，文件夹下面创建一个.conf的文件， 123456789101112131415161718|--conf |--servers |--test.conf |--fastcgi.conf |--fastcgi_params |--koi-utf |--koi-win |--mime.types |--nginx.conf |--scgi_params |--uwsgi_params |--win-utf|--contrib|--docs|--html|--logs|--temp|--nginx.exe 12#gzip on; /*我这里是33行*/include servers/*; /*include在这里是导入servers下面所有的.conf文件*/ servers文件夹下test.conf文件配置 1234567891011121314server &#123; #监听的端口号 listen 80; #用来指定ip地址或者域名，多个配置之间用空格分隔,假如在本地运行，配置www.xx.com就需要去更改电脑的host文件 #如何更改host：在C:\Windows\System32\drivers\etc目录下的host文件中添加一条DNS记录：127.0.0.1 www.test.com server_name test.com; #反向代理代理服务器访问模式 location / &#123; proxy_pass http://127.0.0.1:8888; //代理的地址 &#125;&#125; 通过node先启动一个服务 12345const http = require('http');http.createServer((req,res)=&gt;&#123; console.log('请求的地址',req.headers.host) res.end('请求了')&#125;).listen(8888) 在浏览器地址栏输入www.test.com启动的server.js后台就会打印出来代理请求的地址 1请求的地址 127.0.0.1:8888 设置hostnginx为了实现反向代理的需求而增加了一个ngx_http_proxy_module模块。其中proxy_set_header指令就是该模块需要读取的配置文件。在这里，所有设置的值的含义和http请求头中的含义完全相同，除了Host外还有X-Forward-For。Host的含义是表明请求的主机名，因为nginx作为反向代理使用，而如果后端的服务器设置有类似防盗链或者根据http请求头中的host字段来进行路由或判断功能的话，如果反向代理层的nginx不重写请求头中的host字段，将会导致请求失败【默认反向代理服务器会向后端真实服务器发送请求，并且请求头中的host字段应为proxy_pass指令设置的服务器】。同理，X_Forward_For字段表示该条http请求是有谁发起的？如果反向代理服务器不重写该请求头的话，那么后端真实服务器在处理时会认为所有的请求都来在反向代理服务器，如果后端有防攻击策略的话，那么机器就被封掉了。因此，在配置用作反向代理的nginx中一般会增加两条配置，修改http的请求头： 12proxy_set_header Host $http_host;proxy_set_header X-Forward-For $remote_addr; 这里的$http_host和$remote_addr都是nginx的导出变量，可以再配置文件中直接使用。如果Host请求头部没有出现在请求头中，则$http_host值为空，但是$host值为主域名。因此，一般而言，会用$host代替$http_host变量，从而避免http请求中丢失Host头部的情况下Host不被重写的失误。12345location / &#123; proxy_pass http://127.0.0.1:8888; //代理的地址 proxy_set_header Host $host; proxy_set_header X-Forward-For $remote_addr; &#125; 这个时候server.js下面打印的地址就是指定的host了1请求的地址 www.test.com]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo写博客与发布]]></title>
    <url>%2F2019%2F03%2F22%2FHexo%2F</url>
    <content type="text"><![CDATA[一、写博客刚开始时候不知道怎么设置标签和分类，然后网上找了一些资料搞定了，记录一下，先创建一个.md的文件放到 /source/_posts文件夹中，在刚建的.md文件中进行一系列的操作。 操作先在git bash中命令新建.md的文件1hexo new newpapername 然后source/_posts文件夹下面新创建个newpapername.md文件，打开newpapername.md文件就可以写自己的东西了，原来自动生成的是下面的样子 1234---title: newpapernamedate: 2019-03-22 15:38:48--- 这个时候根据自己文章的内容进行分类和添加标签，下面是这篇文件设定的标签和文件夹12345678910---title: hexo写博客与发布date: 2019-03-22 14:11:32categories: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级# - 实用技术 # 一级分类- 个人博客 # 二级分类 tags: # 这里写的标签会自动汇集到 tags 页面上- 实用 # 可配置多个标签，注意格式- 个人博客--- 这里我只设置了一个分类，默认是一级分类，生成后的图片如下 这里点击分类的时候显示就能显示自己设定的个人博客分类了 上面设定了两个标签，一个是实用，一个是个人博客，现在也一样可以显示了 补充一下：将本地图片截取的图片生成在线地址，我这里用的是七牛云地址已经贴上。 二、发布到github操作 生成SSH添加到GitHub在git bash 中输入命令，设置用户名和邮箱 12git config --global user.name "yourname"git config --global user.email "youremail" 然后创建SSH,一路回车 1ssh-keygen -t rsa -C "youremail" 这个时候电脑C盘里面就生成了.ssh的文件夹 简单的说ssh就是一个密钥，id_rsa是私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。然后在GitHub的settings中找到SSH and GPG keys 选项 查看是否成功 1ssh -T git@github.com 将hexo部署到GitHub我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改YourgithubName 就是你创建的gitHub名字。 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装deploy-git,也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后执行 123hexo clean hexo generate # 可以缩写 hexo ghexo deploy # 可以缩写 hexo d 注意deploy时可能要你输入username和password。 部署到GitHub出现404页面出现这个问题的主要原因是因为起名字的时候没有和前面博客名字保持一致，只需要在settings中将名字改成一致，保存后，刷新页面即可 三、 在其他电脑上操作 跟上面一样需要安装安装git，安装node，安装hexo，安装配置name，配置邮箱名，配置ssh key密钥……等 1234git，配置name，配置邮箱名，生成ssh key 与github配置授权 将github上面的代码克隆下来 1git clone git@github.com:Silly-Bo/Silly-Bo.github.io.git 进入到克隆的文件仓库中 123cd xxx.github.ionpm install npm install hexo-deployer-git --save 生成、部署 12hexo g hexo d 可以写新博客了 1hexo new newpage 别忘记提交 123git add . git commit -m &apos;XXXX&apos;git push 如果已经在克隆过的电脑上要使用的话，需要先拉新项目 1git pull 参考：zjufangzh]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[搭建此博客的目的就是为了能记录自己平时学习的点滴，之前学习的一些东西太散不好集中复习，现在搭建这个小博客，就是希望能够以后学习的东西可以记录在一起，便于自己更好的复习查看。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
