<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2F2019%2F05%2F28%2FDOM%2F</url>
    <content type="text"><![CDATA[一、DOM节点1.节点分类 元素节点： 每个Html元素 属性节点： Html元素的属性 文本节点： Html内的文本 注释节点： 注释 &lt;!-----&gt; 文档节点： 整个文档document 2.节点类型(nodeType) 元素节点 1 文本节点 3 注释节点 8 文档节点（document） 9 文档声明 10 3.节点名称(nodeName) 元素节点：与标签名相同（大写） 文本节点：为#text 注释节点：为#comment 文档节点：为#document 文档声明：为html 二、DOM关系1.父子之间 查找子级 childNodes 获取子节点（包括所有节点：文本节点，元素节点，注释节点…） children 获取子元素 firstChild 第一个子节点 firstElementChild 第一个子元素 lastChild 最后一个子节点 lastElementChild 最后一个子元素 12345678&lt;div id="div"&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt; &lt;p&gt;p5&lt;/p&gt; &lt;p&gt;p6&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425let div = document.querySelect('#div');console.log(div.childNodes) /*这里获取的所有节点包括了换行的文本节点*///NodeList(13) [text, p, text, p, text, p, text, p, text, p, text, p, text]console.log(div.children)//HTMLCollection(6) [p, p, p, p, p, p]//通过nodeType节点类型，也可以将childNodes所有的节点给过滤成类似children获取的所有的元素// 因为元素节点是 1 过滤时候做个判断就好let _div = div.childNodes_div = [..._div].filter(item=&gt;&#123; return item.nodeType == 1&#125;)console.log(_div)// (6) [p, p, p, p, p, p]//第一个子节点console.log(div.firstChild) //#text//第一个子元素console.log(div.firstElementChild); //&lt;p&gt;p1&lt;/p1&gt;//最后一个子节点console.log(div.lastChild) //#text//最后一个子元素console.log(div.lastElementChild); //&lt;p&gt;p6&lt;/p1&gt; 2.兄弟之间 查找兄弟 nextSibling 下一个兄弟节点 nextElementSibling 下一个兄弟元素 previousSibling 上一个兄弟节点 previousElementSibling 上一个兄弟元素1同上面的实例就不写了 3.父子之间 查找父级 parentNode 父节点 parentElement 父元素 offsetParent 定位父级（元素根据定位的父级，如果父级没有定位，那么找到的就是他的父级） 三、NodeList 和 HTMLCollection 区别NodeList childNodes querySelectorAll HTMLCollection children getElementsByTagName getElementsByClassName 区别： NodeList有forEach方法，HTMLCollection没有forEach HTMLCollection每次调用都会去动态获取内容，NodeList中，childNodes有动态更新，但是querySelectorAll不会动态更新 四、DOM属性操作setAttribute() 设置属性getAttribute() 获取属性removeAttribute() 移除属性 五、自定义属性12345678&lt;div id="box" class="mm" data-bobo="test"&gt;&lt;/div&gt;&lt;script&gt; let div = document.querySelector('#box') console.log(div.dataset.bobo); //test 这里是获取自定义属性 div.dataset.mytest="test2" //设置自定义属性 console.log(div.dataset.mytest) //test2&lt;/script&gt; 六、offset 、client 和 scroll1. offset123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; #box&#123; margin: 50px auto; position: relative; width: 500px; height: 500px; border: 1px solid #000; &#125; #div&#123; position: absolute; left: 150px; top: 150px; width: 100px; height: 100px; padding: 10px; /* margin: 10px; */ border: 5px solid #ccc; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // offset 可视的 可见的 // offsetWith 可视宽度 + border + padding // offsetHeight 可视高度 + border + padding // offsetTop 当前元素相对于其 offsetParent 元素的顶部的距离 top + margin // offsetLeft 当前元素相对于其 offsetParent 元素的左侧的距离 left + margin let div = document.querySelector('#div'); // console.log(div.offsetWidth); // console.log(div.offsetTop); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. client1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; #box&#123; margin: 50px auto; position: relative; width: 500px; height: 500px; border: 1px solid #000; &#125; #div&#123; position: absolute; left: 150px; top: 150px; width: 100px; height: 100px; padding: 10px; /* margin: 10px; */ border: 5px solid #ccc; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // client // clientWidth 元素本身 with + padding // clientHeight 元素本身 height + padding // clientTop 元素上边框的宽度 =&gt; border // clientLeft 元素左边框的宽度 =&gt; border // console.log(div.clientWidth,div.clientHeight); console.log(div.clientTop,div.clientLeft); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3. scroll12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;style&gt; #box&#123; margin: 50px auto; position: relative; width: 300px; height: 300px; border: 1px solid #000; overflow: auto; &#125; #div&#123; position: absolute; width: 100px; background: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div id="div"&gt; 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // scrollHeight 如果内容高度比元素自己高度高，则是内容高度，否则就是元素自身的高度 // scrollWidth 如果内容宽度比元素自己宽度宽，则是内容宽度，否则就是元素自身的宽度，注意：需要减掉滚动条的宽度 // scrollTop 元素上下滚动的高度 // scrollLeft 元素左右滚动的距离 let box = document.querySelector('#box'); // console.log(box.scrollHeight); //内容的高度 // console.log(box.scrollWidth); //内容的宽度 setTimeout(()=&gt;&#123; console.log(box.scrollTop) //上下滚动的高度 &#125;,2000) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、 获取元素在可视区的绝对位置123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; height: 100px; border: 1px solid #000; &#125; #box&#123; padding: 10px; background-color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div id="box"&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;script&gt; let div = document.querySelector('#box') div.onclick =()=&gt;&#123; console.log(div.getBoundingClientRect()) //获取到一个对象 DOMRect &#123;x: 8, y: 64, width: 1333, height: 102, top: 64, …&#125; // bottom: 166 元素底部，相对于可视区顶部的距离 // height: 122 元素的可视高度，就是元素自身高度 + padding + border // left: 0 元素左侧距离可视区左边的距离 // right: 1349 元素右侧距离可视区右边的距离 // top: 64 元素相对于可视区顶部的距离 // width: 1349 元素可视区宽度 &#125; &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; #box&#123; position: relative; height: 300px; width: 300px; border: 1px solid #000; margin: 0 auto; &#125; #div&#123; position: absolute; top: 100px; left: 100px; height: 100px; width: 100px; background: red; border: 5px solid #000; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div id="div"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; /* 因为 getBoundingClientRect有兼容， 下面自己简单封装一个到可视区的距离 */ let div = document.querySelector('#div'); console.log(getOffsetClient(div)) function getOffsetClient(el)&#123; let left = el.offsetLeft; let top = el.offsetTop; while(el.offsetParent)&#123; el = el.offsetParent; left += el.offsetLeft + el.clientLeft; top += el.offsetTop + el.clientTop; &#125; return &#123;left,top&#125; &#125; &lt;/script&gt;&lt;/body&gt; 八、 表格的一些操作123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;table border="1" id="table" width="300"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;th&gt;2&lt;/th&gt; &lt;th&gt;3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; let table = document.querySelector("#table") // table.tHead 获取的是 thead表头 // table.tBodies 获取的是 tbody // rows 获取行（tr） // cells 获取单元格（ td 或者 th ） console.log(table.tHead) console.log(table.tHead.rows[0].cells[0]) console.log(table.tBodies) console.log(table.tBodies[0].rows) console.log(table.tBodies[0].rows[0].cells) console.log(table.tBodies[0].rows[0].cells[0])&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x的使用]]></title>
    <url>%2F2019%2F05%2F18%2Fwebpack%2F</url>
    <content type="text"><![CDATA[本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 一、安装 在文件夹中先初始化项目生成package.json文件，便于更好的管理1npm init --yes 通过npm下载webpack，这里下载的@4.27.1版本,注意--save-dev是开发环境下依赖1npm install webpack --save-dev 二、简单打包小测试 在创建的文件中分别创建main.js，App.js，index.html,然后再引入vue.js文件 文件目录|–node_modules|–App.js|–main.js|–index.html|–vue.js|–package.json 1.1. main.js文件里: 123456789101112import Vue from './vue.js';import App from './App.js';new Vue(&#123; el:'#app', components:&#123; App &#125;, template:` &lt;App/&gt; `&#125;) 1.2. App.js文件夹里: 123456var app = &#123; template:` &lt;div&gt;我是App文件&lt;/div&gt; `&#125;export default app 1.3. index.html文件夹里: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="./build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打包通过命令webpack ./main.js -o ./build.js --mode &#39;development&#39;将文件目录中的文件打包webpack ./main.js -o ./build.js --mode &apos;development&apos;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中v-model实现原理]]></title>
    <url>%2F2019%2F05%2F09%2Fv-model%2F</url>
    <content type="text"><![CDATA[vue中有很多指令，今天记录一下v-model指令的实现原理 一、先了解下input输入框中的 input事件oninput事件在用户在输入元素值发生变化时立即触发；该事件在 &lt;input&gt; 或 &lt;textarea&gt; 元素的值发生改变时触发。 缺点： 从脚本中修改值不会触发事件。 从浏览器下拉提示框里选取值时不会触发。 IE9 以下不支持，所以IE9以下可用onpropertychange事件（只在IE下支持，其他浏览器不支持 ）代替。12&lt;!-- js下面的方法使用 --&gt; &lt;input type="text" oninput="fn()"&gt; 二、现在贴出在vue中的实现原理123456789101112131415161718&lt;div id="app"&gt; &lt;input type="text" v-bind:value="msg" v-on:input="change"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:'#app', data:&#123; msg: '我是内容' &#125;, methods: &#123; change(e)&#123; console.log(e.target.value) this.msg = e.target.value &#125; &#125;, &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js中的classList]]></title>
    <url>%2F2019%2F05%2F03%2Fclasslist%2F</url>
    <content type="text"><![CDATA[Element.classList 操作元素的class属性，Element.className操作class, 但是二者区别还是很大的。 className这里通过点击事件，直接就是将class=&#39;box&#39;替换成了class=&#39;active&#39;，元素上原来设置的.box样式也完全被.active替换掉了。 1234567&lt;div id="box" class="box"&gt;&lt;/div&gt;var box = document.querySelector('#box');box.onclick = function()&#123; box.className = "active"&#125; classList如果换成classList来设置，那么可以支持两个设置的属性同事存在，之前设置的那个的属性不会被覆盖1234567var box = document.querySelector('#box');box.onclick = function()&#123; box.classList.add("active")&#125; classlist几种用法123456add(String [, String]) //添加指定的类值。如果这些类已经存在于元素的属性中，那么它们将被忽略。remove(String [,String]) //删除指定的类值。item (Number) //按集合中的索引返回类值。toggle (tring [, force]) //当只有一个参数时：切换 class value; 即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true。当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它contains(String) //检查元素的类属性中是否存在指定的类值。replace(oldClass, newClass) //用一个新类替换已有类。 示例1234567891011121314151617181920212223242526272829303132const div = document.createElement('div');div.className = 'foo';// our starting state: &lt;div class="foo"&gt;&lt;/div&gt;console.log(div.outerHTML);// use the classList API to remove and add classesdiv.classList.remove("foo");div.classList.add("anotherclass");// &lt;div class="anotherclass"&gt;&lt;/div&gt;console.log(div.outerHTML);// if visible is set remove it, otherwise add itdiv.classList.toggle("visible");// add/remove visible, depending on test conditional, i less than 10div.classList.toggle("visible", i &lt; 10 );console.log(div.classList.contains("foo"));// add or remove multiple classesdiv.classList.add("foo", "bar", "baz");div.classList.remove("foo", "bar", "baz");// add or remove multiple classes using spread syntaxconst cls = ["foo", "bar"];div.classList.add(...cls); div.classList.remove(...cls);// replace class "foo" with class "bar"div.classList.replace("foo", "bar");]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex状态管理]]></title>
    <url>%2F2019%2F04%2F16%2Fvuex%2F</url>
    <content type="text"><![CDATA[Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。用于属性的状态管理，方便其他组件的使用，因为现在公司项目中用到了vuex，所以现在也带着学习记录一下。 一、利用npm包管理工具以为在项目上线以后还是需要用到的，所以下载的需要加上–save1npm install --save 未完待续……]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript内置对象Math、Date……]]></title>
    <url>%2F2019%2F03%2F26%2Fnewpage-1%2F</url>
    <content type="text"><![CDATA[JavaScript提供了一些内置的对象和函数，内置对象提供编程的几种最常用的功能，JavaScript内置对象有以下几种。Math对象：处理所有的数学运算Date对象：处理日期和时间的存储、转化和表达String对象：处理所有的字符串操作Array对象：提供一个数组的模型、存储大量有序的数据Boolean对象：布尔对象，一个布尔变量就是一个布尔对象(没有可用的属性和方法)Number对象：数值对象,一个数值变量就是一个数值对象RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具Event对象：提供JavaScript事件的各种处理信息 一、Math与其它全局对象不同的是, Math 不是一个构造器. Math 的所有属性和方法都是静态的. 1. 属性下面列出来的属性，好像我用到过的就Math.PI.12345678Math.E // 2.718281828459045Math.PI // 圆周率，一个圆的周长和直径之比 3.141592653589793Math.LN2 // 2的自然对数, 约等于0.693.Math.LN10 // 10的自然对数, 约等于 2.303.Math.LOG2E // 以2为底E的对数, 约等于 1.443.Math.LOG10E // 以10为底E的对数, 约等于 0.434.Math.SQRT1_2 // 1/2的平方根, 约等于 0.707.Math.SQRT2 // 2的平方根,约等于 1.414. 2.方法一大堆方法里面，反正我用到的不是很多，相对较为常用的放在的了最下方，注意ceil，和floor值为负数的时候取整，不能被负数给带到坑里面了12345678910111213141516171819202122232425262728293031323334353637Math.abs(x) // 返回x的绝对值.Math.acos(x) // 返回x的反余弦值.Math.acosh(x) // 返回x的反双曲余弦值.Math.asin(x) // 返回x的反正弦值.Math.asinh(x) // 返回x的反双曲正弦值.Math.atan(x) // 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值.Math.atanh(x) // 返回 x 的反双曲正切值.Math.atan2(y, x) // 返回 y/x 的反正切值.Math.cbrt(x) // 返回x的立方根.Math.clz32(x) // 返回一个32位整数的前导零的数量。Math.cos(x) // 返回x的余弦值.Math.cosh(x) // 返回x的双曲余弦值.Math.exp(x) // 返回 Ex, 当x为参数, E 是欧拉常数 (2.718...), 自然对数的底.Math.expm1(x) // 返回 exp(x)-1 的值.Math.fround(x) // 返回数字的最接近的单精度浮点型表示.Math.hypot([x[,y[,…]]]) // 返回其参数平方和的平方根。Math.imul(x) // 返回32位整数乘法的结果。Math.log(x) // 返回一个数的自然对数（loge， 即ln）。Math.log1p(x) // 返回 1 加上一个数字的的自然对数（loge， 即ln）。Math.log10(x) // 返回以10为底数的x的对数。Math.log2(x) // 返回以2为底数的x的对数。Math.max([x[,y[,…]]]) // 返回0个到多个数值中最大值.Math.min([x[,y[,…]]]) // 返回0个到多个数值中最小值.Math.sign(x) // 返回x的符号函数, 判定x是正数,负数还是0.Math.sin(x) // 返回正弦值.Math.sinh(x) // 返回x的双曲正弦值.Math.tan(x) // 返回x的正切值.Math.tanh(x) // 返回x的双曲正切值.Math.toSource()// 返回字符串 "Math".Math.trunc(x) // 返回x的整数部分,去除小数.Math.round(x) // 返回四舍五入后的整数.Math.random() // 返回0到1之间的伪随机数([0 1)包括0，不包括1）Math.pow(x,y) // 返回x的y次方.Math.sqrt(x) // 返回x的平方根.Math.ceil(x) // 返回x向上取整后的值（向上取整）.Math.floor(x) // 返回小于x的最大整数（向下取整）. 二、DateDate对象基于1970年1月1日（世界标准时间）起的毫秒,new Date()根据本地时间返回，里面也有很多方法可以获取到指定的年月日时分秒毫秒等，也可以设置时间，值得注意的是，获取月份的时候是个坑，因为月份是从0开始的，获取月份（0-11）,也就是1月份是0，所以一般将获取到的月份+1，达到我们正常的（1-12）月 1. 属性Date.prototype 属性表示Date构造函数的原型1Date.prototype 2. 方法12345678910111213141516var myDate = new Date() // 创建一个日期对象myDate.getFullYear() // 返回年份 myDate.getMonth() // 返回月份数（0-11） myDate.getDay() // 返回星期中第几天(0-6),想要得到星期几，需要+1myDate.getDate() // 返回日myDate.getHours() // 返回时myDate.getMinutes() // 返回分myDate.getSeconds() // 返回秒myDate.getTime() // 返回从1970年1月1日00:00到现在的毫秒数(时间戳)myDate.setFullYear() // 设置年份(4位数)myDate.setMonth() // 设置月份(0-11)myDate.setDate() // 设置日(1-31)myDate.setHours() // 设置小时数(0-23)myDate.setMinutes() // 设置分钟数(0-59)myDate.setSeconds() // 设置秒数(0-59)myDate.setMilliseconds() // 设置毫秒(0-999) 三、String1. 属性123constructor // 对创建该对象的函数的引用length // 字符串的长度prototype // 允许您向对象添加属性和方法 2. 方法1234567891011121314151617181920212223242526272829303132333435anchor() // 创建 HTML 锚。big() // 用大号字体显示字符串。 small() // 使用小字号来显示字符串。blink() // 显示闪动字符串。 bold() // 使用粗体显示字符串。fixed() // 以打字机文本显示字符串。 fontcolor() // 使用指定的颜色来显示字符串。fontsize() // 使用指定的尺寸来显示字符串。fromCharCode() // 从字符编码创建一个字符串。italics() // 使用斜体显示字符串。localeCompare()// 用本地特定的顺序来比较两个字符串。toSource() // 代表对象的源代码。link() // 将字符串显示为链接。lastIndexOf() // 从后向前搜索字符串。indexOf() // 检索字符串。charAt() // 返回在指定位置的字符。charCodeAt() // 返回在指定的位置的字符的 Unicode 编码。 concat() // 连接字符串。match() // 找到一个或多个正则表达式的匹配。replace() // 替换与正则表达式匹配的子串。search() // 检索与正则表达式相匹配的值。slice() // 提取字符串的片断，并在新的字符串中返回被提取的部分。split() // 把字符串分割为字符串数组。strike() // 使用删除线来显示字符串。sup() // 把字符串显示为上标。sub() // 把字符串显示为下标。 substr() // 从起始索引号提取字符串中指定数目的字符。substring() // 提取字符串中两个指定的索引号之间的字符。toLocaleLowerCase() // 把字符串转换为小写，通常和toLowerCase()一样。toLocaleUpperCase() // 把字符串转换为大写，通常和toUpperCase()一样。toLowerCase() // 把字符串转换为小写。toUpperCase() // 把字符串转换为大写。toString() // 返回字符串。valueOf() // 返回某个字符串对象的原始值。 举栗子因为string平时操作的太多了，举个例子先 anchor() 创建 HTML 锚。这里加这么多的&lt;/br&gt;为的就是让页面出现滚动条，这个的时候点击html中自己定义的锚链接按钮，然后就会链接到通过str.anchor(&#39;anchorname&#39;)方法定义锚点上面了 123&lt;a href=&quot;#anchorname&quot;&gt;锚链接&lt;/a&gt; var str = &apos;hello world&apos; document.write(`&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;` + str.anchor(&apos;anchorname&apos;)) link() 用于把字符串显示为超链接。 这里是通过link()方法，生成a标签，然后将地址挂在a标签的href上 12 var str = '点击我传送至百度'document.write(str.link('https://www.baidu.com')) lastIndexOf() 从后向前搜索字符串。 12 参考：W3school]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery事件绑定方式有哪些]]></title>
    <url>%2F2019%2F03%2F25%2Fnewpage%2F</url>
    <content type="text"><![CDATA[jQuery中提供了四种事件监听方式bing、live、delegate、on，对应的解除监听的函数分别是unbind、lie、undelegate、off bind()直接绑定在元素上bind(type,[data],function(){})type:事件类型，如click、change、mouseover等;data:传入监听函数的参数，通过event.data取到。可选;function:监听函数，可传入event对象，这里的event是jQuery封装的event对象，与原生的event对象有区别 12345678源码： bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn ); &#125;$('#btn li').bind('click',function()&#123;&#125;) live()通过冒泡的方式绑定到元素上的，更适合列表类型的，绑定到document DOM节点上，和bind()不一样，live支持动态数据 1234567live: function( types, data, fn ) &#123; jQuery( this.context ).on( types, this.selector, data, fn ); return this; &#125; 可以看到live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了,正常来说就是document了，live没有将事件绑定在自己的身上而是事件委托绑在了document上 delegate()参数多了一个selector，用来指定触发事件的目标元素，监听器将被绑定在调用此方法的元素上，小范围的使用事件代理，性能要优于live() 12345delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn ); &#125; on$(selector).on(event,childSelector,data,function)1.7版本新添加的，也是推荐使用的事件绑定方法。其实bind、live、delegate都是通过该方法实现的： 1234567891011121314151617181920212223bind: function( types, data, fn ) &#123; return this.on( types, null, data, fn );&#125;,unbind: function( types, fn ) &#123; return this.off( types, null, fn );&#125;,live: function( types, data, fn ) &#123; jQuery( this.context ).on( types, this.selector, data, fn ); return this;&#125;,die: function( types, fn ) &#123; jQuery( this.context ).off( types, this.selector || "**", fn ); return this;&#125;,delegate: function( selector, types, data, fn ) &#123; return this.on( types, selector, data, fn );&#125;,undelegate: function( selector, types, fn ) &#123; return arguments.length == 1 ? this.off( selector, "**" ) : this.off( types, selector, fn ); 使用on方法和上面方法一样1234567891011// Bind$( "#members li a" ).on( "click", function( e ) &#123;&#125; ); $( "#members li a" ).bind( "click", function( e ) &#123;&#125; );// Live$( document ).on( "click", "#members li a", function( e ) &#123;&#125; ); $( "#members li a" ).live( "click", function( e ) &#123;&#125; );// Delegate$( "#members" ).on( "click", "li a", function( e ) &#123;&#125; ); $( "#members" ).delegate( "li a", "click", function( e ) &#123;&#125; ); 参考：https://blog.csdn.net/liwenfei123/article/details/80408537]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装和基础代理配置]]></title>
    <url>%2F2019%2F03%2F24%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[一、安装windows电脑可以通过点击Nginx到官方网址进行下载，Mac电脑可以通过brew(又叫homebrew，Mac中的一款软件包管理工具）通过命令进行下载，下面是通过windows电脑演示 安装点击Nginx到官方网址下载 将下载的文件解压，放在的C盘下面，打开文件夹，找到nginx.exe直接点击启动，也可以通过CMD终端，cd到文件夹下输入strat nginx启动 12345678网上找的一些nginx常用命令start nginx 开启nginxnginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。nginx -s reopen 重新打开日志文件。nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。。nginx -v 显示 nginx 的版本。 启动后在浏览器地址栏输入localhost:8080,就会显示下图页面了 二、配置 找到nginx解压后的文件夹，我的文件夹在c盘根目录 1C:\nginx-1.14.2 打开的文件夹中找到nginx.conf文件并打开，找到下面的这个代码，在下面加一段代码include servers/*,如果有这段代码，直接将前面的#去掉，然后在跟nginx.conf同级目录下，创建一个servers文件夹，文件夹下面创建一个.conf的文件， 123456789101112131415161718|--conf |--servers |--test.conf |--fastcgi.conf |--fastcgi_params |--koi-utf |--koi-win |--mime.types |--nginx.conf |--scgi_params |--uwsgi_params |--win-utf|--contrib|--docs|--html|--logs|--temp|--nginx.exe 12#gzip on; /*我这里是33行*/include servers/*; /*include在这里是导入servers下面所有的.conf文件*/ servers文件夹下test.conf文件配置 1234567891011121314server &#123; #监听的端口号 listen 80; #用来指定ip地址或者域名，多个配置之间用空格分隔,假如在本地运行，配置www.xx.com就需要去更改电脑的host文件 #如何更改host：在C:\Windows\System32\drivers\etc目录下的host文件中添加一条DNS记录：127.0.0.1 www.test.com server_name test.com; #反向代理代理服务器访问模式 location / &#123; proxy_pass http://127.0.0.1:8888; //代理的地址 &#125;&#125; 通过node先启动一个服务 12345const http = require('http');http.createServer((req,res)=&gt;&#123; console.log('请求的地址',req.headers.host) res.end('请求了')&#125;).listen(8888) 在浏览器地址栏输入www.test.com启动的server.js后台就会打印出来代理请求的地址 1请求的地址 127.0.0.1:8888 设置hostnginx为了实现反向代理的需求而增加了一个ngx_http_proxy_module模块。其中proxy_set_header指令就是该模块需要读取的配置文件。在这里，所有设置的值的含义和http请求头中的含义完全相同，除了Host外还有X-Forward-For。Host的含义是表明请求的主机名，因为nginx作为反向代理使用，而如果后端的服务器设置有类似防盗链或者根据http请求头中的host字段来进行路由或判断功能的话，如果反向代理层的nginx不重写请求头中的host字段，将会导致请求失败【默认反向代理服务器会向后端真实服务器发送请求，并且请求头中的host字段应为proxy_pass指令设置的服务器】。同理，X_Forward_For字段表示该条http请求是有谁发起的？如果反向代理服务器不重写该请求头的话，那么后端真实服务器在处理时会认为所有的请求都来在反向代理服务器，如果后端有防攻击策略的话，那么机器就被封掉了。因此，在配置用作反向代理的nginx中一般会增加两条配置，修改http的请求头： 12proxy_set_header Host $http_host;proxy_set_header X-Forward-For $remote_addr; 这里的$http_host和$remote_addr都是nginx的导出变量，可以再配置文件中直接使用。如果Host请求头部没有出现在请求头中，则$http_host值为空，但是$host值为主域名。因此，一般而言，会用$host代替$http_host变量，从而避免http请求中丢失Host头部的情况下Host不被重写的失误。12345location / &#123; proxy_pass http://127.0.0.1:8888; //代理的地址 proxy_set_header Host $host; proxy_set_header X-Forward-For $remote_addr; &#125; 这个时候server.js下面打印的地址就是指定的host了1请求的地址 www.test.com]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo写博客与发布]]></title>
    <url>%2F2019%2F03%2F22%2FHexo%2F</url>
    <content type="text"><![CDATA[一、写博客刚开始时候不知道怎么设置标签和分类，然后网上找了一些资料搞定了，记录一下，先创建一个.md的文件放到 /source/_posts文件夹中，在刚建的.md文件中进行一系列的操作。 操作先在git bash中命令新建.md的文件1hexo new newpapername 然后source/_posts文件夹下面新创建个newpapername.md文件，打开newpapername.md文件就可以写自己的东西了，原来自动生成的是下面的样子 1234---title: newpapernamedate: 2019-03-22 15:38:48--- 这个时候根据自己文章的内容进行分类和添加标签，下面是这篇文件设定的标签和文件夹12345678910---title: hexo写博客与发布date: 2019-03-22 14:11:32categories: # 这里写的分类会自动汇集到 categories 页面上，分类可以多级# - 实用技术 # 一级分类- 个人博客 # 二级分类 tags: # 这里写的标签会自动汇集到 tags 页面上- 实用 # 可配置多个标签，注意格式- 个人博客--- 这里我只设置了一个分类，默认是一级分类，生成后的图片如下 这里点击分类的时候显示就能显示自己设定的个人博客分类了 上面设定了两个标签，一个是实用，一个是个人博客，现在也一样可以显示了 补充一下：将本地图片截取的图片生成在线地址，我这里用的是七牛云地址已经贴上。 二、发布到github操作 生成SSH添加到GitHub在git bash 中输入命令，设置用户名和邮箱 12git config --global user.name "yourname"git config --global user.email "youremail" 然后创建SSH,一路回车 1ssh-keygen -t rsa -C "youremail" 这个时候电脑C盘里面就生成了.ssh的文件夹 简单的说ssh就是一个密钥，id_rsa是私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。然后在GitHub的settings中找到SSH and GPG keys 选项 查看是否成功 1ssh -T git@github.com 将hexo部署到GitHub我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改YourgithubName 就是你创建的gitHub名字。 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 安装deploy-git,也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后执行 123hexo clean hexo generate # 可以缩写 hexo ghexo deploy # 可以缩写 hexo d 注意deploy时可能要你输入username和password。 部署到GitHub出现404页面出现这个问题的主要原因是因为起名字的时候没有和前面博客名字保持一致，只需要在settings中将名字改成一致，保存后，刷新页面即可 三、 在其他电脑上操作 跟上面一样需要安装安装git，安装node，安装hexo，安装配置name，配置邮箱名，配置ssh key密钥……等 1234git，配置name，配置邮箱名，生成ssh key 与github配置授权 将github上面的代码克隆下来 1git clone git@github.com:Silly-Bo/Silly-Bo.github.io.git 进入到克隆的文件仓库中 123cd xxx.github.ionpm install npm install hexo-deployer-git --save 生成、部署 12hexo g hexo d 可以写新博客了 1hexo new newpage 别忘记提交 123git add . git commit -m &apos;XXXX&apos;git push 如果已经在克隆过的电脑上要使用的话，需要先拉新项目 1git pull 参考：zjufangzh]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[搭建此博客的目的就是为了能记录自己平时学习的点滴，之前学习的一些东西太散不好集中复习，现在搭建这个小博客，就是希望能够以后学习的东西可以记录在一起，便于自己更好的复习查看。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
